<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DC_Available_Algorithm_List" xml:space="preserve">
    <value>List of available algorithms</value>
  </data>
  <data name="DC_Err_FileNotFound" xml:space="preserve">
    <value>File not found.</value>
  </data>
  <data name="DC_Err_HeaderVersionNotMatch" xml:space="preserve">
    <value>Header version mismatch.</value>
  </data>
  <data name="DC_Err_IncorrectEncryptedDataChecksum" xml:space="preserve">
    <value>Incorrect checksum of encrypted data.</value>
  </data>
  <data name="DC_Err_IncorrectHeaderChecksum" xml:space="preserve">
    <value>Incorrect checksum of header.</value>
  </data>
  <data name="DC_Err_IncorrectRawDataChecksum" xml:space="preserve">
    <value>Incorrect checksum of raw data.</value>
  </data>
  <data name="DC_Err_InvalidAlgorithm" xml:space="preserve">
    <value>Invalid algorithm.</value>
  </data>
  <data name="DC_Err_InvalidBufferSize" xml:space="preserve">
    <value>Invalid buffer size.</value>
  </data>
  <data name="DC_Err_InvalidHeaderClass" xml:space="preserve">
    <value>Invalid header class.</value>
  </data>
  <data name="DC_Err_AccessDenied" xml:space="preserve">
    <value>Access denied.</value>
  </data>
  <data name="DC_Err_InvalidHeaderFieldValue" xml:space="preserve">
    <value>Invalid header field value.</value>
  </data>
  <data name="DC_Err_InvalidParameter" xml:space="preserve">
    <value>Invalid parameter.</value>
  </data>
  <data name="DC_Err_InvalidPasswordOrDataCorrupted" xml:space="preserve">
    <value>Invalid password or data is corrupted.</value>
  </data>
  <data name="DC_Err_InvalidSignature" xml:space="preserve">
    <value>Invalid signature.</value>
  </data>
  <data name="DC_Err_IOError" xml:space="preserve">
    <value>I/O error.</value>
  </data>
  <data name="DC_Err_NoIputFile" xml:space="preserve">
    <value>No input file.</value>
  </data>
  <data name="DC_Err_NotSupportedVersion" xml:space="preserve">
    <value>Not supported version.</value>
  </data>
  <data name="DC_Err_OutOfMemory" xml:space="preserve">
    <value>Out of memory.</value>
  </data>
  <data name="DC_Err_PathTooLong" xml:space="preserve">
    <value>Path too long.</value>
  </data>
  <data name="DC_Err_StreamReadError" xml:space="preserve">
    <value>Stream read error.</value>
  </data>
  <data name="DC_Err_StreamWriteError" xml:space="preserve">
    <value>Stream write error.</value>
  </data>
  <data name="DC_Err_SucceedButCleanupFailed" xml:space="preserve">
    <value>Task was succeed, but cannot remove input file.</value>
  </data>
  <data name="DC_Err_Success" xml:space="preserve">
    <value>Task succeed.</value>
  </data>
  <data name="DC_Error_Code" xml:space="preserve">
    <value>Error Code</value>
  </data>
  <data name="DC_Error_Description" xml:space="preserve">
    <value>Error Description</value>
  </data>
  <data name="DC_License_Info" xml:space="preserve">
    <value>License Information</value>
  </data>
  <data name="DC_Option_Algorithm" xml:space="preserve">
    <value>Determine which algorithm used in cryptographic process. (Default is 'AES')</value>
  </data>
  <data name="DC_Err_AmbiguousOption" xml:space="preserve">
    <value>Ambiguous option.</value>
  </data>
  <data name="DC_Option_BufferSize" xml:space="preserve">
    <value>Determine size of buffer used in cryptographic process. (Default is 4096, this value must higher or equal than 128)</value>
  </data>
  <data name="DC_Option_Cleanup" xml:space="preserve">
    <value>Delete input file after cryptographic process if succeed.</value>
  </data>
  <data name="DC_Option_Comment" xml:space="preserve">
    <value>Sets a comment for file. (This option only available on encryption)</value>
  </data>
  <data name="DC_Option_Decrypt" xml:space="preserve">
    <value>Decrypt an encrypted file.</value>
  </data>
  <data name="DC_Option_DisableVerification" xml:space="preserve">
    <value>Disable checksum verification.</value>
  </data>
  <data name="DC_Option_HeaderVersion" xml:space="preserve">
    <value>Sets a version of header.</value>
  </data>
  <data name="DC_Option_IV" xml:space="preserve">
    <value>* Sets an IV(Initial Vector) used in cryptographic process.</value>
  </data>
  <data name="DC_Option_Out" xml:space="preserve">
    <value>Sets an output file.</value>
  </data>
  <data name="DC_Option_Overwrite" xml:space="preserve">
    <value>Overwrite output file.</value>
  </data>
  <data name="DC_Option_Password" xml:space="preserve">
    <value>* Sets a password used in cryptographic process.</value>
  </data>
  <data name="DC_Option_RunTest" xml:space="preserve">
    <value>Run the test about encrypted file. (This option cannot used with `-c, --cleanup` and `-w, --overwrite` options)</value>
  </data>
  <data name="DC_Option_ShowAlgorithmList" xml:space="preserve">
    <value>Show list of algorithms available.</value>
  </data>
  <data name="DC_Option_ShowHeaderInfo" xml:space="preserve">
    <value>Display header information of input file.</value>
  </data>
  <data name="DC_Option_ShowVersion" xml:space="preserve">
    <value>Display version and license information in console.</value>
  </data>
  <data name="DC_Option_Usage" xml:space="preserve">
    <value>Display usage of DataChest application.</value>
  </data>
  <data name="DC_Option_Verbose" xml:space="preserve">
    <value>Display progress of cryptographic process verbosely in console.</value>
  </data>
  <data name="DC_PerformanceLogging_Start" xml:space="preserve">
    <value>[{0}] Performance logging started.</value>
  </data>
  <data name="DC_PerformanceLogging_Ended" xml:space="preserve">
    <value>[{0}] Performance logging ended.</value>
  </data>
  <data name="DC_Used_Library" xml:space="preserve">
    <value>Referenced libraries</value>
  </data>
  <data name="DC_Err_DirectoryNotFound" xml:space="preserve">
    <value>Directory not found.</value>
  </data>
  <data name="DC_Err_EncodingError" xml:space="preserve">
    <value>Encoding error.</value>
  </data>
  <data name="DC_Err_ErrorCausedUDPR" xml:space="preserve">
    <value>Error caused in UDPR(User Defined Processing Routine).</value>
  </data>
  <data name="DC_Err_FileAlreadyExists" xml:space="preserve">
    <value>File already exists.</value>
  </data>
  <data name="DC_File" xml:space="preserve">
    <value>File</value>
  </data>
  <data name="DC_Option" xml:space="preserve">
    <value>Option</value>
  </data>
  <data name="DC_Usage" xml:space="preserve">
    <value>Usage</value>
  </data>
  <data name="DC_Keys_Description" xml:space="preserve">
    <value>* Locate the file first, if file is not exist; use the string itself as key(or IV). However, if string begins with {0} or {1} used in accordance with the applicable rules. {0} - use the string itself as a key(or IV). {1} - use the contents of the file. (If file is not exist or access denied for file, error occurred)</value>
  </data>
  <data name="DC_PerformanceLogging_Aborted" xml:space="preserve">
    <value>[{0}] Aborted. ({1}: {2}, {3}: {4})</value>
  </data>
  <data name="DC_PerformanceLogging_Checkpoint_Created" xml:space="preserve">
    <value>[{0}] '{1}' Started.</value>
  </data>
  <data name="DC_PerformanceLogging_Checkpoint_Finished" xml:space="preserve">
    <value>[{0}] '{1}' Ended. ({2}: {3}, {4}: {5})</value>
  </data>
  <data name="DC_PerformanceLogging_ElapsedTime" xml:space="preserve">
    <value>Elapsed time</value>
  </data>
  <data name="DC_PerformanceLogging_None" xml:space="preserve">
    <value>None</value>
  </data>
  <data name="DC_PerformanceLogging_Speed" xml:space="preserve">
    <value>Speed</value>
  </data>
  <data name="DC_PerformanceLogging_Error" xml:space="preserve">
    <value>Error</value>
  </data>
  <data name="DC_Application_Info" xml:space="preserve">
    <value>Application Information</value>
  </data>
  <data name="DC_PerformanceLogging_Exception" xml:space="preserve">
    <value>Exception</value>
  </data>
  <data name="DC_PerformanceLogging_WriteLine" xml:space="preserve">
    <value>[{0}] {1}</value>
  </data>
  <data name="DC_PerformanceLogging_ActualSize" xml:space="preserve">
    <value>Actual size</value>
  </data>
  <data name="DC_PerformanceLogging_Summary" xml:space="preserve">
    <value>{0}: {1}{2}: {3}{4}: {5}</value>
  </data>
  <data name="DC_PerformanceLogging_Total_ElapsedTime" xml:space="preserve">
    <value>Total elapsed time</value>
  </data>
</root>